export class WallReshapingTool extends window.go.Tool{constructor(t){super();const n=new window.go.Shape;n.figure="Diamond";n.desiredSize=new window.go.Size(12,12);n.fill="lightblue";n.stroke="dodgerblue";n.cursor="move";this._handleArchetype=n;this._handle=null;this._adornedShape=null;this._reshapeObjectName="SHAPE";this._angle=0;this._length=0;this._isBuilding=false;this._isIntersecting=false;this._joinedWalls=new window.go.Set;this._returnPoint=null;this._returnData=null;this._joinedWalls=new window.go.Set;this._wallIntersecting=null;if(t)Object.assign(this,t)}get handleArchetype(){return this._handleArchetype}get handle(){return this._handle}set handle(t){this._handle=t}get adornedShape(){return this._adornedShape}set adornedShape(t){this._adornedShape=t}get angle(){return this._angle}set angle(t){this._angle=t}get length(){return this._length}set length(t){this._length=t}get reshapeObjectName(){return this._reshapeObjectName}set reshapeObjectName(t){this._reshapeObjectName=t}get isBuilding(){return this._isBuilding}set isBuilding(t){this._isBuilding=t}get returnData(){return this._returnData}set returnData(t){this._returnData=t}get returnPoint(){return this._returnPoint}set returnPoint(t){this._returnPoint=t}get isIntersecting(){return this._isIntersecting}set isIntersecting(t){this._isIntersecting=t}get wallIntersecting(){return this._wallIntersecting}set wallIntersecting(t){this._wallIntersecting=t}get joinedWalls(){return this._joinedWalls}set joinedWalls(t){this._joinedWalls=t}updateAdornments(i){if(i===null||i instanceof window.go.Link)return;if(i.isSelected&&!this.diagram.isReadOnly){const n=i.findObject(this.reshapeObjectName);if(n!==null&&n.part!==null&&n.part.data.category==="WallGroup"){const e=n;let t=i.findAdornment(this.name);if(t===null){t=this.makeAdornment(e)}if(t!==null&&e.part!==null&&e.geometry!=null){const a=e.geometry;const s=a.bounds;const r=e.part.actualBounds;const o=t.findObject("BODY");if(o===null)return;o.desiredSize=s.size;t.elements.each(function(t){if(t.name===undefined)return;let n=0;let e=0;switch(t.name){case"sPt":{n=i.data.startpoint.x-r.x;e=i.data.startpoint.y-r.y;break}case"ePt":{n=i.data.endpoint.x-r.x;e=i.data.endpoint.y-r.y;break}}let a=Math.min((n-s.x)/s.width,1);let o=Math.min((e-s.y)/s.height,1);if(a<0)a=0;if(o<0)o=0;if(a>1)a=1;if(o>1)o=1;if(isNaN(a))a=0;if(isNaN(o))o=0;t.alignment=new window.go.Spot(Math.max(0,a),Math.max(0,o))});i.addAdornment(this.name,t);t.location=e.getDocumentPoint(window.go.Spot.Center);return}}}i.removeAdornment(this.name)}canStart(){if(!this.isEnabled)return false;const t=this.diagram;if(t===null||t.isReadOnly)return false;if(!t.allowReshape)return false;if(!t.lastInput.left)return false;const n=this.findToolHandleAt(t.firstInput.documentPoint,this.name);return n!==null||this.isBuilding}doActivate(){const t=this.diagram;if(t===null)return;if(this.isBuilding){if(this.adornedShape!==null&&this.adornedShape.part!==null){const n=this.adornedShape.part;this.handle=this.findToolHandleAt(n.data.endpoint,this.name);this.returnPoint=n.data.startpoint}}else{this.handle=this.findToolHandleAt(t.firstInput.documentPoint,this.name);if(this.handle===null)return;const e=this.handle.part;const a=e.adornedObject;const n=a.part;if(!a)return;this.adornedShape=a;this.returnPoint=this.handle.name==="sPt"?n.data.startpoint:n.data.endpoint;const o=n.memberParts;if(o.count!==0){const i=new window.go.Map;o.iterator.each(function(t){i.add(t.data.key,t.location)});this.returnData=i}}this.startTransaction(this.name);this.isActive=true}doMouseMove(){const a=this.diagram;const o=this;if(o.handle===null)return;const t=o.handle.part;const i=t.adornedPart;let s=a.lastInput.documentPoint;if(o.isActive&&a!==null){if(a.lastInput.shift){const r=o.handle.name;const l=r==="sPt"?i.data.endpoint:i.data.startpoint;let t=l.directionPoint(s);const d=Math.sqrt(l.distanceSquaredPoint(s));t=Math.round(t/45)*45;let n=new window.go.Point(l.x+d,l.y);const c=l.x;const p=l.y;n=n.offset(-c,-p);n=n.rotate(t);n=n.offset(c,p);s=n}const n=a.findNodesByExample({category:"WallGroup"});n.iterator.each(function(e){if(e.data.key!==i.data.key){const t=e.data.startpoint;const n=e.data.endpoint;if(a.isPointInWall(e,s)){s=s.projectOntoLineSegmentPoint(e.data.startpoint,e.data.endpoint);o.isIntersecting=true}if(Math.sqrt(t.distanceSquaredPoint(s))<10){s=t}else if(Math.sqrt(n.distanceSquaredPoint(s))<10){s=n}}});const e=o.getClosestIntersectingWall(s);if(e===null||o.wallIntersecting!==null){if(o.wallIntersecting!==null&&o.wallIntersecting!==undefined&&o.wallIntersecting.data!==null){o.performMiteringOnWall(o.wallIntersecting)}}if(e!=null){o.isIntersecting=true;o.wallIntersecting=e;s=s.projectOntoLineSegmentPoint(e.data.startpoint,e.data.endpoint);const u=Math.sqrt(s.distanceSquaredPoint(e.data.startpoint));const h=Math.sqrt(s.distanceSquaredPoint(e.data.endpoint));if(u<25){s=e.data.startpoint}else if(h<10){s=e.data.endpoint}}else{o.isIntersecting=false;if(o.wallIntersecting!==null&&o.wallIntersecting!==undefined&&o.wallIntersecting.data!==null&&a.getWallsIntersection(i,o.wallIntersecting)===null){o.wallIntersecting=null}}o.calcAngleAndLengthFromHandle(s);o.reshape(s)}o.performMiteringOnWall(i);a.updateWallDimensions();a.updateWallAngles()}getClosestIntersectingWall(t){const n=this;if(n.handle===null)return null;const e=n.handle.part;const a=e.adornedPart;const o=n.handle.name;const r=o==="sPt"?a.data.endpoint:a.data.startpoint;const i={key:"wall",category:"WallGroup",caption:"Wall",type:"Wall",startpoint:r,smpt1:r,smpt2:r,endpoint:t,empt1:t,empt2:t,thickness:parseFloat(n.diagram.model.modelData.wallThickness),isGroup:true,notes:""};n.diagram.model.addNodeData(i);const l=n.diagram.findPartForKey(i.key);const d=n.diagram;const s=n.diagram.findNodesByExample({category:"WallGroup"});let c=null;let p=Number.MAX_VALUE;s.iterator.each(function(i){if(i.data.key!==a.data.key&&i.data.key!==l.data.key){const t=d.getWallsIntersection(l,i);let n=false;const e=parseFloat(Math.sqrt(i.data.startpoint.distanceSquaredPoint(r)).toFixed(2));const a=parseFloat(Math.sqrt(r.distanceSquaredPoint(i.data.endpoint)).toFixed(2));const o=parseFloat(Math.sqrt(i.data.startpoint.distanceSquaredPoint(i.data.endpoint)).toFixed(2));if(Math.abs(e+a-o)<=.1){n=true}if(t!==null&&!n){const s=Math.sqrt(r.distanceSquaredPoint(t));if(s<p){p=s;c=i}}}});d.remove(l);return c}pointsApproximatelyEqual(t,n){const e=t.x;const a=n.x;const o=t.y;const i=n.y;const s=Math.abs(a-e);const r=Math.abs(i-o);if(r<.05&&s<.05){return true}return false}performMitering(n,e){const a=this;const o=this.diagram;const i=n.data.startpoint;const s=n.data.endpoint;const r=e.data.startpoint;const l=e.data.endpoint;const t=n.data.thickness;const d=e.data.thickness;const c=Math.sqrt(i.distanceSquaredPoint(s));const p=Math.sqrt(r.distanceSquaredPoint(l));const u=o.getWallsIntersection(n,e);if(u===null){return}let h=a.pointsApproximatelyEqual(i,u)?s:i;let f=a.pointsApproximatelyEqual(r,u)?l:r;let m=null;let g=null;if(!a.pointsApproximatelyEqual(i,u)&&!a.pointsApproximatelyEqual(s,u)){m=n;g=e}else if(!a.pointsApproximatelyEqual(r,u)&&!a.pointsApproximatelyEqual(l,u)){m=e;g=n}if(m!==null&&g!==null&&n.data.key===g.data.key){if(a.isClockwise(h,u,m.data.startpoint)){f=m.data.startpoint}else{f=m.data.endpoint}}if(m!==null&&g!==null&&e.data.key===g.data.key){if(a.isClockwise(u,f,m.data.startpoint)){h=m.data.startpoint}else{h=m.data.endpoint}}const y=u.directionPoint(h);const w=u.directionPoint(f);let P=Math.abs(y-w+360)%360;if(Math.abs(P-180)<.1){return}P=P*(Math.PI/180);const A=Math.abs(d/(2*Math.sin(P)));const W=Math.abs(t/(2*Math.sin(P)));const x=Math.sqrt(h.distanceSquaredPoint(u));const M=Math.sqrt(u.distanceSquaredPoint(f));const k=(h.x-u.x)/x*A;const q=(h.y-u.y)/x*A;const S=(f.x-u.x)/M*W;const E=(f.y-u.y)/M*W;const b=new window.go.Point(u.x+k+S,u.y+q+E);const I=new window.go.Point(u.x-k-S,u.y-q-E);const N=Math.min(c,p);if(Math.sqrt(b.distanceSquaredPoint(u))>N){return}const D=a.isClockwise(u,h,b)?I:b;if(isNaN(D.x)||isNaN(D.y)){return}if(a.pointsApproximatelyEqual(i,u)||a.pointsApproximatelyEqual(s,u)){let t=null;if(a.pointsApproximatelyEqual(h,i)){if(a.isClockwise(h,u,D)){t="empt1"}else{t="empt2"}}else if(a.pointsApproximatelyEqual(h,s)){if(a.isClockwise(h,u,D)){t="smpt2"}else{t="smpt1"}}if(t!==null){o.model.setDataProperty(n.data,t,D);o.updateWall(n)}}if(a.pointsApproximatelyEqual(r,u)||a.pointsApproximatelyEqual(l,u)){let t=null;if(a.pointsApproximatelyEqual(f,r)){if(a.isClockwise(f,u,D)){t="empt1"}else{t="empt2"}}else if(a.pointsApproximatelyEqual(f,l)){if(a.isClockwise(f,u,D)){t="smpt2"}else{t="smpt1"}}if(t!==null){o.model.setDataProperty(e.data,t,D);o.updateWall(e)}}}getAllWallIntersectionPoints(){const o=this;const i=o.diagram;const t=i.findNodesByExample({category:"WallGroup"});const s=new window.go.Set;t.iterator.each(function(n){const t=i.findNodesByExample({category:"WallGroup"});t.iterator.each(function(t){if(t.data.key===n.data.key)return;const e=i.getWallsIntersection(n,t);let a=true;if(e!==null){s.iterator.each(function(t){const n=window.go.Point.parse(t);if(o.pointsApproximatelyEqual(n,e)){a=false}});if(a){s.add(window.go.Point.stringify(e))}}})});return s}getAllWallsAtIntersection(a,o){if(o===undefined||o===null){o=true}const i=this;const t=i.diagram;const s=new window.go.List;if(a===null){return s}t.findObjectsNear(a,1,function(t){if(t.part!==null){return t.part}return null},function(t){if(!(t instanceof window.go.Group&&t.category==="WallGroup"&&(o||!t.data.isDivider)&&!s.contains(t)))return false;const n=t.data.startpoint;const e=t.data.endpoint;return i.isPointOnSegment(n,e,a)},true,s);return s}doWallsShareAnEndpoint(t,n){const e=this;const a=t.data.startpoint;const o=t.data.endpoint;const i=n.data.startpoint;const s=n.data.endpoint;if(e.pointsApproximatelyEqual(a,i)||e.pointsApproximatelyEqual(a,s)||e.pointsApproximatelyEqual(o,i)||e.pointsApproximatelyEqual(o,s)){return true}return false}maybeSplitWall(){const n=this;if(n.handle===null)return;const t=n.handle.part;const e=t.adornedPart;const a=n.handle.name;const o=a==="sPt"?e.data.startpoint:e.data.endpoint;const i=n.joinedWalls;const s=n.getAllWallsAtIntersection(o);s.remove(e);i.iterator.each(function(t){s.remove(t)});if(s.count===1){const r=s.first();if(r!==null){if(!n.doWallsShareAnEndpoint(e,r)){n.maybePerformWallSplit(r,o)}}}if(n.isBuilding){const l=o===e.data.startpoint?e.data.endpoint:e.data.startpoint;const d=n.getAllWallsAtIntersection(l);d.remove(e);i.iterator.each(function(t){s.remove(t)});if(d.count===1){const r=d.first();if(r!==null){if(!n.doWallsShareAnEndpoint(e,r)){n.maybePerformWallSplit(r,l)}}}}if(i!==null){i.iterator.each(function(t){n.splitNewWall(t)})}}splitNewWall(e){const o=this;const a=this.diagram;const t=a.findNodesByExample({category:"WallGroup"});const i=new window.go.Set;t.iterator.each(function(t){const n=a.getWallsIntersection(e,t);if(n!==null){i.add(n)}});i.iterator.each(function(a){const t=o.getAllWallsAtIntersection(a);t.iterator.each(function(t){const n=t.data.startpoint;const e=t.data.endpoint;if(!o.pointsApproximatelyEqual(n,a)&&!o.pointsApproximatelyEqual(e,a)){o.maybePerformWallSplit(t,a)}})})}maybePerformWallSplit(p,u){const h=this;const f=h.diagram;const a=p.data.startpoint;const o=p.data.endpoint;const t=p.data.isDivider?"Divider":"Wall";const n={key:"wall",category:"WallGroup",caption:t,type:t,color:p.data.color,startpoint:a,endpoint:u,smpt1:a,smpt2:a,empt1:u,empt2:u,thickness:p.data.thickness,isGroup:true,notes:"",isDivider:p.data.isDivider};const e={key:"wall",category:"WallGroup",caption:t,type:t,color:p.data.color,startpoint:u,endpoint:o,smpt1:u,smpt2:u,empt1:o,empt2:o,thickness:p.data.thickness,isGroup:true,notes:"",isDivider:p.data.isDivider};const i=Math.sqrt(n.startpoint.distanceSquaredPoint(n.endpoint));const s=Math.sqrt(e.startpoint.distanceSquaredPoint(e.endpoint));const r=f.findNodesByExample({category:"WallGroup"});let l=false;r.iterator.each(function(t){const n=t.data.startpoint;const e=t.data.endpoint;if(h.pointsApproximatelyEqual(a,n)&&h.pointsApproximatelyEqual(u,e)||h.pointsApproximatelyEqual(a,e)&&h.pointsApproximatelyEqual(u,n)){l=true}if(h.pointsApproximatelyEqual(u,n)&&h.pointsApproximatelyEqual(o,e)||h.pointsApproximatelyEqual(u,e)&&h.pointsApproximatelyEqual(o,n)){l=true}});if(i>1&&s>1&&!l){f.model.addNodeData(n);f.model.addNodeData(e);const m=f.findNodeForData(n);const g=f.findNodeForData(e);h.premiterWall(m);h.premiterWall(g);h.performMiteringAtPoint(u,false);if(h.handle!==null){const P=f.findNodesByExample({category:"RoomNode"});const A=h.handle.part;const W=A.adornedPart;P.iterator.each(function(d){const c=d.data.boundaryWalls;for(let l=0;l<c.length;l++){const r=c[l];const t=r[0];if(t===p.data.key){let o=false;const t=h.pointsApproximatelyEqual(W.data.startpoint,u)?W.data.endpoint:W.data.startpoint;const n=h.getAllWallsAtIntersection(t);n.iterator.each(function(a){for(let e=0;e<c.length;e++){const t=c[e];const n=t[0];if(a.data.key===n&&a.data.key!==W.data.key){o=true}}});if(o){let i=false;const s=h.pointsApproximatelyEqual(m.data.startpoint,u)?m.data.endpoint:m.data.startpoint;const t=h.getAllWallsAtIntersection(s);t.remove(p);t.iterator.each(function(a){for(let n=0;n<c.length;n++){const t=c[n];const e=t[0];if(a.data.key===e&&m.data.key!==a.data.key){const o=f.findNodeForKey(e);const t=h.pointsApproximatelyEqual(o.data.startpoint,s)?o.data.endpoint:o.data.startpoint;const n=h.getAllWallsAtIntersection(t);n.iterator.each(function(a){for(let e=0;e<c.length;e++){const t=c[e];const n=t[0];if(n===a.data.key&&n!==o.data.key){i=true}}})}}});const n=i?m:g;const e=h.getUpdatedEntry(r,n);f.startTransaction();const a=c.slice();a[l]=e;f.model.setDataProperty(d.data,"boundaryWalls",a);f.commitTransaction()}else{let t=new window.go.List;t.add(W);t.add(m);t.add(g);t=f.sortWallsClockwiseWithSetStartWall(t,W);const n=h.getUpdatedEntry(r,t.toArray()[1]);const e=h.getUpdatedEntry(r,t.toArray()[2]);f.startTransaction();const a=c.slice();a.splice(l,1,e);a.splice(l+1,0,n);f.model.setDataProperty(d.data,"boundaryWalls",a);f.commitTransaction()}}}})}const d=f.findNodesByExample({group:p.data.key});const c=new window.go.Set;c.add(m);c.add(g);h.maintainWallParts(d,c);f.remove(p);h.premiterWall(m);h.premiterWall(g);const y=h.pointsApproximatelyEqual(m.data.startpoint,u)?m.data.endpoint:m.data.startpoint;const w=h.pointsApproximatelyEqual(g.data.startpoint,u)?g.data.endpoint:g.data.startpoint;h.performMiteringAtPoint(u,false);h.performMiteringAtPoint(y,false);h.performMiteringAtPoint(w,false)}}splitAllWalls(){const o=this;const t=o.getAllWallIntersectionPoints();t.iterator.each(function(t){const a=window.go.Point.parse(t);const n=o.getAllWallsAtIntersection(a);n.iterator.each(function(t){const n=t.data.startpoint;const e=t.data.endpoint;if(!o.pointsApproximatelyEqual(n,a)&&!o.pointsApproximatelyEqual(e,a)){o.maybePerformWallSplit(t,a)}})})}areWallsParallel(t,n){const e=this;const a=this.diagram;const o=t.data.startpoint;const i=t.data.endpoint;const s=n.data.startpoint;const r=n.data.endpoint;let l=false;const d=+o.directionPoint(i);const c=+s.directionPoint(r);if(Math.abs(d-c)<1||Math.abs(d-c)>179&&Math.abs(d-c)<181){l=true}return l}isWallColinear(e,t){const a=this;const n=this.diagram;if(e.data.isDivider!==t.data.isDivider){return false}const o=e.data.startpoint;const i=e.data.endpoint;const s=t.data.startpoint;const r=t.data.endpoint;let l=false;if(a.areWallsParallel(e,t)){let t=null;if(a.pointsApproximatelyEqual(o,s)||a.pointsApproximatelyEqual(o,r)){t=o}else if(a.pointsApproximatelyEqual(i,s)||a.pointsApproximatelyEqual(i,r)){t=i}if(t!==null){const d=a.getAllWallsAtIntersection(t);let n=false;d.iterator.each(function(t){if(!a.areWallsParallel(t,e)){n=true}});if(!n){l=true}}}return l}findAllColinearWalls(n,e){if(e===null||e===undefined){e=new window.go.Set}e.add(n);const a=this;const t=a.diagram;const o=t.findNodesByExample({category:"WallGroup"});o.iterator.each(function(t){if(a.isWallColinear(n,t)&&e!==undefined&&!e.contains(t)){e.add(t);a.findAllColinearWalls(t,e)}});return e}joinColinearWalls(){const t=this;if(t.handle===null)return;const n=t.handle.part;const e=n.adornedPart;const a=t.findAllColinearWalls(e);const o=t.performColinearWallJoining(a,e);if(o!==null){t.joinedWalls.add(o)}const i=t.getAllWallsAtIntersection(t.returnPoint);if(i.count===2){const s=i.toArray();const r=s[0];const l=s[1];if(t.isWallColinear(r,l)){const d=new window.go.Set;d.add(r);d.add(l);const c=t.performColinearWallJoining(d,r);if(c!==null){t.joinedWalls.add(c)}}}}performColinearWallJoining(s,t){const r=this;const p=r.diagram;const n=new window.go.Set;const e=s.first();if(e===null){return null}if(t===undefined){t=e}const a=e.data.category;s.iterator.each(function(t){if(t.data.category!==a){return}});if(s.count>1){let l=null;let d=null;let c=0;const o=s.copy();const i=new window.go.Set;s.iterator.each(function(r){const t=p.findNodesByExample({group:r.data.key});i.addAll(t);o.iterator.each(function(t){const n=r.data.startpoint;const e=r.data.endpoint;const a=t.data.startpoint;const o=t.data.endpoint;const i=[n,e];const s=[a,o];for(let t=0;t<i.length;t++){const a=i[t];for(let e=0;e<s.length;e++){const t=s[e];const n=Math.sqrt(a.distanceSquaredPoint(t));if(n>c){c=n;l=a;d=t}}}});n.add(r)});const u={key:"wall",category:"WallGroup",caption:"Wall",type:"Wall",color:t.data.color,startpoint:l,endpoint:d,smpt1:l,smpt2:l,empt1:d,empt2:d,thickness:t.data.thickness,isGroup:true,notes:""};p.model.addNodeData(u);const h=p.findNodeForData(u);const f=p.findNodesByExample({category:"RoomNode"});f.iterator.each(function(o){const i=o.data.boundaryWalls;for(let a=0;a<i.length;a++){const e=i[a];const t=e[0];const n=p.findNodeForKey(t);if(s.contains(n)){r.performMiteringOnWall(h);const t=r.getUpdatedEntry(e,h);p.startTransaction();const n=i.slice();n[a]=t;p.model.setDataProperty(o.data,"boundaryWalls",n);p.commitTransaction()}}});const m=new window.go.Set;m.add(h);r.performMiteringOnWall(h);r.maintainWallParts(i,m);n.iterator.each(function(t){p.remove(t)});r.performMiteringOnWall(h);return h}return null}maintainWallParts(t,n){const e=this;const a=e.diagram;const o=[];t.iterator.each(function(e){const t=e.location;n.iterator.each(function(n){if(a.isPointInWall(n,t)){const t=a.findClosestLocOnWall(n,e);if(t!==null){a.model.setDataProperty(e.data,"group",n.data.key);e.location=t.projectOntoLineSegmentPoint(n.data.startpoint,n.data.endpoint);if(e.category==="WindowNode"){a.model.setDataProperty(e.data,"height",n.data.thickness)}if(e.category==="DoorNode"){a.model.setDataProperty(e.data,"doorOpeningHeight",n.data.thickness)}}else{o.push(e)}}})});for(let t=0;t<o.length;t++){a.remove(o[t])}}getUpdatedEntry(t,n){const e=this;const a=e.diagram;const o=t[0];const i=a.findNodeForKey(o);const s=t[1];const r=[n.data.key,null];const l=i.data["smpt"+s];const d=i.data["empt"+s];function pointAtX(t,n,e){const a=(n.y-t.y)/(n.x-t.x);const o=t.y+(e-t.x)*a;return new window.go.Point(e,o)}const c=pointAtX(l,d,n.data.smpt1.x);const p=pointAtX(l,d,n.data.smpt2.x);const u=n.data.smpt1.distanceSquaredPoint(c);const h=n.data.smpt2.distanceSquaredPoint(p);if(u<h){r[1]=1}else{r[1]=2}return r}joinAllColinearWalls(){const e=this;const t=e.diagram;const n=t.findNodesByExample({category:"WallGroup"});const a=new window.go.Set;n.iterator.each(function(n){if(!a.contains(n)){a.add(n);const t=new window.go.Set;t.add(n);e.findAllColinearWalls(n,t);a.addAll(t);e.performColinearWallJoining(t,n)}});e.premiterAllWalls()}translateAndRotatePoint(t,n,e){const a=t.copy();const o=t.copy();o.offset(0,e);o.offset(-a.x,-a.y).rotate(n).offset(a.x,a.y);return o}premiterWall(t,n){const e=this;const a=e.diagram;const o=t.data.startpoint.directionPoint(t.data.endpoint);const i=t.data.thickness;const s=t.data.startpoint;const r=t.data.endpoint;switch(n){case"smpt1":{const l=e.translateAndRotatePoint(s,o,i/2);a.model.setDataProperty(t.data,"smpt1",l);break}case"smpt2":{const d=e.translateAndRotatePoint(s,o+180,i/2);a.model.setDataProperty(t.data,"smpt2",d);break}case"empt1":{const c=e.translateAndRotatePoint(r,o,i/2);a.model.setDataProperty(t.data,"empt1",c);break}case"empt2":{const p=e.translateAndRotatePoint(r,o+180,i/2);a.model.setDataProperty(t.data,"empt2",p);break}default:{const c=e.translateAndRotatePoint(r,o,i/2);a.model.setDataProperty(t.data,"empt1",c);const p=e.translateAndRotatePoint(r,o+180,i/2);a.model.setDataProperty(t.data,"empt2",p);const l=e.translateAndRotatePoint(s,o,i/2);a.model.setDataProperty(t.data,"smpt1",l);const d=e.translateAndRotatePoint(s,o+180,i/2);a.model.setDataProperty(t.data,"smpt2",d);break}}a.updateWall(t)}premiterAllWalls(){const n=this;const t=n.diagram;const e=t.findNodesByExample({category:"WallGroup"});e.iterator.each(function(t){n.premiterWall(t)})}performMiteringOnWall(t){const n=this;const e=t.data.startpoint;const a=t.data.endpoint;n.premiterWall(t);n.performMiteringAtPoint(e,true);n.performMiteringAtPoint(a,true)}performMiteringAtPoint(p,t){if(t===null||t===undefined){t=true}const u=this;const h=u.diagram;const n=u.getAllWallsAtIntersection(p,false);if(t){n.iterator.each(function(n){if(u.pointsApproximatelyEqual(n.data.startpoint,p)||u.pointsApproximatelyEqual(n.data.endpoint,p)){const t=u.pointsApproximatelyEqual(n.data.startpoint,p)?"s":"e";u.premiterWall(n,t+"mpt1");u.premiterWall(n,t+"mpt2")}})}n.sort(function(t,n){const e=h.getWallsIntersection(t,n);if(e===null)return 0;const a=t.data.startpoint;const o=t.data.endpoint;const i=n.data.startpoint;const s=n.data.endpoint;const r=u.pointsApproximatelyEqual(p,a)?o:a;const l=u.pointsApproximatelyEqual(p,i)?s:i;const d=e.directionPoint(r);const c=e.directionPoint(l);if(d>c)return 1;else if(d<c)return-1;else return 0});n.reverse();const e=n.toArray();for(let n=0;n<e.length;n++){const a=e[n];let t=null;if(n+1===e.length){t=e[0]}else{t=e[n+1]}u.performMitering(a,t)}}performAllMitering(){const u=this;const h=u.diagram;u.premiterAllWalls();const t=u.getAllWallIntersectionPoints();t.iterator.each(function(t){const p=window.go.Point.parse(t);const n=u.getAllWallsAtIntersection(p);n.sort(function(t,n){const e=h.getWallsIntersection(t,n);if(e===null)return 0;const a=t.data.startpoint;const o=t.data.endpoint;const i=n.data.startpoint;const s=n.data.endpoint;const r=u.pointsApproximatelyEqual(p,a)?o:a;const l=u.pointsApproximatelyEqual(p,i)?s:i;const d=e.directionPoint(r);const c=e.directionPoint(l);if(d>c)return 1;else if(d<c)return-1;else return 0});n.reverse();const e=n.toArray();for(let n=0;n<e.length;n++){const a=e[n];let t=null;if(n+1===e.length){t=e[0]}else{t=e[n+1]}u.performMitering(a,t)}})}isClockwise(t,n,e){return(n.x-t.x)*(e.y-t.y)-(n.y-t.y)*(e.x-t.x)>0}isPointOnSegment(t,n,e){const a=Math.sqrt(t.distanceSquaredPoint(e));const o=Math.sqrt(n.distanceSquaredPoint(e));const i=Math.sqrt(t.distanceSquaredPoint(n));if(Math.abs(i-(a+o))<=.1){return true}return false}doMouseUp(){const t=this;const n=this.diagram;if(t.handle===null)return;t.doMouseMove();const e=t.handle.part;const a=e.adornedPart;t.joinColinearWalls();t.maybeSplitWall();t.joinedWalls.clear();const o=new window.go.Set;o.add(a);n.updateAllRoomBoundaries(o);this.stopTool()}doDeactivate(){const o=this.diagram;const t=o;if(this.handle===null)return;const n=this.handle.part;const i=n.adornedPart;const e=i.data.startpoint;const a=i.data.endpoint;const s=Math.sqrt(e.distanceSquared(a.x,a.y));if(s<1){o.remove(i);i.memberParts.iterator.each(function(t){o.remove(t)});const l=[];t.pointNodes.iterator.each(function(t){if(t.data.key.indexOf(i.data.key)!==-1)l.push(t)});if(l.length===2){o.remove(l[0]);o.remove(l[1])}}if(o.lastInput.key==="Escape"&&!this.isBuilding){o.skipsUndoManager=true;o.startTransaction("reset to old data");if(this.handle.name==="sPt")i.data.startpoint=this.returnPoint;else i.data.endpoint=this.returnPoint;this.performAllMitering();t.updateWall(i);if(this.returnData){this.returnData.iterator.each(function(t){const n=t.key;const e=t.value;const a=o.findPartForKey(n);a.location=e;a.rotateObject.angle=i.rotateObject.angle})}o.commitTransaction("reset to old data");o.skipsUndoManager=false}const r=this.diagram.findNodesByExample({category:"GLPointNode"});o.removeParts(r,true);t.updateWallDimensions();o.commitTransaction(this.name);this.isActive=false}makeAdornment(t){const n=new window.go.Adornment;n.type=window.go.Panel.Spot;n.locationObjectName="BODY";n.locationSpot=window.go.Spot.Center;let e=new window.go.Shape;e.name="BODY";e.fill=null;e.stroke=null;e.strokeWidth=0;n.add(e);e=this.makeHandle();e.name="sPt";n.add(e);e=this.makeHandle();e.name="ePt";n.add(e);n.category=this.name;n.adornedObject=t;return n}makeHandle(){const t=this.handleArchetype;return t.copy()}calcAngleAndLengthFromHandle(t){const n=this;const e=this.handle;if(e===null)return;if(n.adornedShape===null)return;let a=null;const o=n.adornedShape.part;if(o===null)return;const i=o.adornments.iterator;let s;while(i.next()){const h=i.value;if(h.category===n.name){s=h}}if(s===undefined)return;const r=s.elements;while(r.next()){const f=r.value;if(f.name!==undefined&&f.name!==e.name){a=f}}if(a===null)return;const l=a.getDocumentPoint(window.go.Spot.Center);const d=t.y-l.y;const c=t.x-l.x;let p=Math.atan2(d,c)*(180/Math.PI);if(p<0)p+=360;n.angle=p;const u=Math.sqrt(t.distanceSquared(l.x,l.y));n.length=u}snapPointToGrid(t){const n=this.diagram;const e=n.toolManager.draggingTool.isGridSnapEnabled?n.model.modelData.gridSize:1;const a=e*Math.round(t.x/e);const o=e*Math.round(t.y/e);const i=new window.go.Point(a,o);return i}reshape(o){const t=this.diagram;const n=this;const e=this.adornedShape;if(e===null)return;if(n.handle===null)return;const i=e.part;if(i===null)return;if(this.diagram.lastInput.shift&&!this.isIntersecting){let e;if(n.handle.name==="sPt")e=i.data.endpoint;else e=i.data.startpoint;const d=t.model.modelData.gridSize;let a=t.model.modelData.gridSize;if(!this.diagram.toolManager.draggingTool.isGridSnapEnabled)a=1;const c=n.angle;const p=n.length;if(c>67.5&&c<112.5){let t=e.y+p;t=a*Math.round(t/a);o=new window.go.Point(e.x,t)}if(c>112.5&&c<202.5){let t=e.x-p;t=a*Math.round(t/a);o=new window.go.Point(t,e.y)}if(c>247.5&&c<292.5){let t=e.y-p;t=a*Math.round(t/a);o=new window.go.Point(e.x,t)}if(c>337.5||c<22.5){let t=e.x+p;t=a*Math.round(t/a);o=new window.go.Point(t,e.y)}if(c>22.5&&c<67.5){let t=Math.sin(.785)*p;t=a*Math.round(t/a)+e.x;let n=Math.cos(.785)*p;n=a*Math.round(n/a)+e.y;o=new window.go.Point(t,n)}if(c>112.5&&c<157.5){let t=Math.sin(.785)*p;t=e.x-a*Math.round(t/a);let n=Math.cos(.785)*p;n=a*Math.round(n/a)+e.y;o=new window.go.Point(t,n)}if(c>202.5&&c<247.5){let t=Math.sin(.785)*p;t=e.x-a*Math.round(t/a);let n=Math.cos(.785)*p;n=e.y-a*Math.round(n/a);o=new window.go.Point(t,n)}if(c>292.5&&c<337.5){let t=Math.sin(.785)*p;t=e.x+a*Math.round(t/a);let n=Math.cos(.785)*p;n=e.y-a*Math.round(n/a);o=new window.go.Point(t,n)}a=d}if(this.diagram.toolManager.draggingTool.isGridSnapEnabled&&!n.isIntersecting&&!this.diagram.lastInput.shift){o=this.snapPointToGrid(o)}else{o=new window.go.Point(o.x,o.y)}const a=n.handle.name;if(a===undefined)return;const s=a==="sPt"?i.data.endpoint:i.data.startpoint;const r=a==="sPt"?i.data.startpoint:i.data.endpoint;this.reshapeWall(i,s,r,o,t);this.updateAdornments(i);this.showMatches();const l=t;l.updateWallDimensions()}showMatches(){const o=this;const t=o.diagram;if(!t.model.modelData.preferences.showWallGuidelines)return;if(o.adornedShape===null)return;if(o.handle===null)return;const n=o.adornedShape.part;let i;if(o.handle.name==="sPt")i=n.data.startpoint;else i=n.data.endpoint;const e=o.adornedShape.part;const a=t.findNodesByExample({category:"GLPointNode"});t.removeParts(a,true);const s=this.diagram.findNodesByExample({category:"WallGroup"});s.iterator.each(function(a){if(e!==null&&a.data.key!==e.data.key){const t=a.findObject("SHAPE");const n=a.data.startpoint;const e=a.data.endpoint;o.checkPtLinedUp(n,i.x,n.x,i);o.checkPtLinedUp(n,i.y,n.y,i);o.checkPtLinedUp(e,i.x,e.x,i);o.checkPtLinedUp(e,i.y,e.y,i)}})}checkPtLinedUp(t,n,e,a){function makeGuideLinePoint(){const t=window.go.GraphObject.make;return t(window.go.Node,"Spot",{locationSpot:window.go.Spot.TopLeft,locationObjectName:"SHAPE",desiredSize:new window.go.Size(1,1)},new window.go.Binding("location","loc",window.go.Point.parse).makeTwoWay(window.go.Point.stringify),t(window.go.Shape,{stroke:null,strokeWidth:1,name:"SHAPE",fill:"black"}))}function makeGuideLineLink(){const t=window.go.GraphObject.make;return t(window.go.Link,t(window.go.Shape,{stroke:"black",strokeWidth:2,name:"SHAPE"},new window.go.Binding("strokeWidth","width"),new window.go.Binding("stroke","stroke")))}const o=this.diagram;const i=Math.abs(n-e);if(i<2){const s={category:"GLPointNode",loc:window.go.Point.stringify(t),key:"glpt"};const r={key:"movingPt",category:"GLPointNode",loc:window.go.Point.stringify(a)};const l={key:"guideline",category:"guideLine",from:"movingPt",to:s.key,stroke:"blue"};const d=makeGuideLinePoint();const c=makeGuideLinePoint();const p=makeGuideLineLink();o.add(d);o.add(c);o.add(p);d.data=s;c.data=r;p.data=l;p.fromNode=d;p.toNode=c}}reshapeWall(c,p,u,e,h){const n=this;const t=c.memberParts;const a=[];const o=c.data.startpoint.directionPoint(c.data.endpoint);t.iterator.each(function(t){a.push(t)});const i=new window.go.Map;let s=null;let r=Number.MAX_VALUE;for(let t=0;t<a.length;t++){const d=a[t];const f=Math.sqrt(d.location.distanceSquaredPoint(p));i.add(d.data.key,f);const m=n.getWallPartEndpoints(d);const g=Math.min(Math.sqrt(m[0].distanceSquaredPoint(u)),Math.sqrt(m[1].distanceSquaredPoint(u)));if(g<r){r=g;s=d}}if(s!==null){const y=s.location;const w=s.data.length;const P=o;const A=new window.go.Point(y.x+w/2,y.y);const W=new window.go.Point(y.x-w/2,y.y);A.offset(-y.x,-y.y).rotate(P).offset(y.x,y.y);W.offset(-y.x,-y.y).rotate(P).offset(y.x,y.y);const x=Math.sqrt(p.distanceSquaredPoint(A));const M=Math.sqrt(p.distanceSquaredPoint(W));let t;let n;if(x>M){t=x;n=A}else{t=M;n=W}const k=Math.sqrt(p.distanceSquaredPoint(e));if(k<t)e=n}if(u===c.data.endpoint){h.model.setDataProperty(c.data,"endpoint",e)}else{h.model.setDataProperty(c.data,"startpoint",e)}const l=h;l.updateWall(c);i.iterator.each(function(t){const n=h.findPartForKey(t.key);const e=t.value;const a=Math.sqrt(p.distanceSquaredPoint(u));const o=new window.go.Point(p.x+e/a*(u.x-p.x),p.y+e/a*(u.y-p.y));n.location=o;const i=c.data.startpoint.directionPoint(c.data.endpoint);const s=c.data.endpoint.directionPoint(c.data.startpoint);const r=Math.abs(n.angle-i);const l=Math.abs(n.angle-s);const d=r<l?i:s;n.angle=d})}getWallPartEndpoints(t){const n=t.location;const e=t.data.length;let a=0;if(t.containingGroup!==null)a=t.containingGroup.rotateObject.angle;else a=180;const o=new window.go.Point(n.x+e/2,n.y);const i=new window.go.Point(n.x-e/2,n.y);o.offset(-n.x,-n.y).rotate(a).offset(n.x,n.y);i.offset(-n.x,-n.y).rotate(a).offset(n.x,n.y);const s=new Array;s.push(o);s.push(i);return s}}